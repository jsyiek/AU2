import abc
from typing import Callable, Generic, TypeVar

ResultT = TypeVar("ResultT")
ErrorT = TypeVar("ErrorT")
TransformT = TypeVar("TransformT")


class Try(abc.ABC, Generic[ResultT, ErrorT]):
    @classmethod
    def from_call(cls, call: Callable[[], ResultT]) -> "Try[ResultT, ErrorT]":
        try:
            val = call()
        except Exception as err:
            return Failure(err)
        else:
            return Success(val)

    def get_or_else(self, or_else: Callable[[ErrorT], ResultT]) -> ResultT:
        """
        If contains success, then returns held result, else invokes passed callable
        """
        ...

    def map(self, fn: Callable[[ResultT], TransformT]) -> "Try[TransformT, ErrorT]":
        """
        Transforms the held value, if any, using the input callable
        """
        ...

    def map_failure(self, fn: Callable[[ErrorT], None]) -> None:
        """
        Applies `fn` if an error type is held
        """
        ...

    def or_throw(self, fn: Callable[[ErrorT], Exception]) -> None:
        """
        Throws exception generated by fn if does not contain a success type
        """
        ...


class Success(Try):
    def __init__(self, value: ResultT):
        self.value = value

    def get_or_else(self, or_else: Callable[[ErrorT], ResultT]) -> ResultT:
        return self.value

    def map(self, fn: Callable[[ResultT], TransformT]) -> Try[TransformT, ErrorT]:
        return Try.from_call(lambda: fn(self.value))

    def map_failure(self, fn: Callable[[ErrorT], None]) -> None:
        pass

    def or_throw(self, fn: Callable[[ErrorT], Exception]) -> None:
        pass


class Failure(Try):
    def __init__(self, err: ErrorT):
        self.err = err

    def get_or_else(self, or_else: Callable[[ErrorT], ResultT]) -> ResultT:
        return or_else(self.err)

    def map(self, fn: Callable[[ResultT], TransformT]) -> Try[TransformT, ErrorT]:
        return self

    def map_failure(self, fn: Callable[[ErrorT], TransformT]) -> TransformT:
        return fn(self.err)

    def or_throw(self, fn: Callable[[ErrorT], Exception]) -> None:
        raise fn(self.err)
